from enum import IntEnum
from threading import current_thread
import traceback
from typing import Callable, Optional
from revvy.mcu.rrrc_control import RevvyControl
from revvy.robot.mcu_error import McuErrorReader

from revvy.utils.logger import get_logger, LogLevel

log = get_logger("ErrorHandler")

# A stack trace has to fit into this size.
MAX_PACKET_SIZE = 500


class RobotErrorType(IntEnum):
    """Where does the error come from."""

    SYSTEM = 0
    MCU = 1
    BLOCKLY_BUTTON = 2
    BLOCKLY_BACKGROUND = 3


class RobotError:
    """Unified error to be sent up."""

    error_type: RobotErrorType
    stack: str
    ref: int
    """Blockly program ID. 255 if not a blockly error."""

    def __init__(self, error_type: RobotErrorType, stack: str, ref: Optional[int]):
        self.error_type = error_type
        self.stack = stack
        self.ref = 255 if ref is None else ref

    def __json__(self):
        return {
            "type": self.error_type,
            "stack": self.stack,
            "ref": self.ref,
        }

    def __bytes__(self) -> bytes:
        return compress_error(self)

    def hash(self) -> int:
        """For easy compare if we have to send it up again or not."""
        return hash((self.error_type, self.stack))


def compress_error(error: RobotError) -> bytes:
    """
    This will be used in the characteristic.
    limit the max size to 500 bytes:
    1 byte: type
    1 byte: ref
    500 bytes: stack trace, that contains the error message at the end.
    """
    stack = error.stack

    # No compression: just dump it as characters, see how that's doing.
    # TODO: cut version number too, as it's in the mobile already.
    if isinstance(error.stack, str):
        stack = error.stack.replace("/home/pi/RevvyFramework/user/packages/revvy-", "")
        stack = stack.encode()

    stack = stack[-500:]

    ret_array = error.error_type.value.to_bytes(1, "big")
    ret_array += error.ref.to_bytes(1, "big")

    ret_array += stack

    return ret_array


class ErrorHandler:
    """
    Handles three types of exceptions:
        - user generated exceptions generated by blockly
            - foreground (button) or
            - background programs (autonomous mode))
        - uncaught system exceptions coming from the pi-firmware
        - errors from the MCU coming through querying the PCB on the I2C bus
            - on every "reset configuration" this should be called to clear the error queue

    The list of errors gather in the error_queue that is being sent to the app.
    Errors that are already in the map, are not added to the queue again.
    They also need to be truncated to 500 bytes to go through a single BLE packet.
    """

    def __init__(self) -> None:
        self._error_queue: list[RobotError] = []
        self._error_map: dict[int, RobotError] = {}
        self._on_error_callback: Optional[Callable] = None
        # self.register_uncaught_exception_handler()

    def register_on_error_callback(self, callback: Callable):
        self._on_error_callback = callback

    def handle_uncaught_system_exception(self, exception_type, value, trace) -> None:
        """Log uncaught exceptions and put them in a queue for reporting."""
        trace = "\t".join(traceback.format_tb(trace))
        log_message = f"U: {exception_type}\nValue: {value}\nTraceback: \n\t{trace}\n\n"

        self.report_error(RobotErrorType.SYSTEM, trace)

        log(log_message, LogLevel.ERROR)

    def register_uncaught_exception_handler(self) -> None:
        import sys

        sys.excepthook = self.handle_uncaught_system_exception
        log("Uncaught exception handler registered")

    def pop_error(self) -> RobotError:
        """Remove and return the last element of the array"""
        return self._error_queue.pop()

    def has_error(self) -> bool:
        """True if error queue not empty"""
        return len(self._error_queue) > 0

    def report_error(self, error_type: RobotErrorType, trace: str, ref: Optional[int] = None):
        """Send error to the queue up if it hasn't been posted already."""
        new_robot_error = RobotError(error_type, f"{trace} [{current_thread().name}]", ref)
        error_hash = new_robot_error.hash()
        if error_hash not in self._error_map:
            self._error_map[error_hash] = new_robot_error

            # Insert at the beginning of the list. (FIFO)
            self._error_queue.insert(0, new_robot_error)
            log("Error QUEUED")
        else:
            log("Caught error reported already, not reporting again.")
        if self._on_error_callback:
            self._on_error_callback(new_robot_error)
        return new_robot_error

    def read_mcu_errors(self, robot_control: RevvyControl):
        """Also clears the error queue on the MCU."""
        error_reader = McuErrorReader(robot_control)
        log("Reading MCU errors...")
        for error_entry in error_reader.read_all():
            self.report_error(
                RobotErrorType.MCU,
                error_entry,  # pyright: ignore - this or report_error's signature is incorrect
                None,
            )

        # This is not super ideal as we are not making sure that the error
        # actually gets sent up, however we do run this function only
        # when the BLE interface has connected, so it should be fine.
        if error_reader.count:
            error_reader.clear()


revvy_error_handler: ErrorHandler = ErrorHandler()
