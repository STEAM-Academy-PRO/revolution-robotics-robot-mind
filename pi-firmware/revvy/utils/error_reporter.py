from enum import IntEnum
import sys
import traceback
from typing import Dict, List
from revvy.mcu.rrrc_control import RevvyControl
from revvy.robot.mcu_error import McuErrorReader

from revvy.utils.logger import get_logger, LogLevel

log = get_logger('ErrorHandler')

# A stack trace has to fit into this size.
MAX_PACKET_SIZE = 500

class RobotErrorType(IntEnum):
    """ Where does the error come from."""
    SYSTEM = 0
    MCU = 1
    BLOCKLY_BUTTON = 2
    BLOCKLY_BACKGROUND = 3


class RobotError:
    """ Unified error to be sent up. """
    error_type: RobotErrorType
    stack: str
    # Blockly errors need a ref, so we can tell
    # which blockly program caused the error.
    ref: int

    def __init__(self, error_type: RobotErrorType, stack: str, ref: int = 0):
        self.error_type = error_type
        self.stack = stack
        self.ref = ref

    def hash(self):
        """ For easy compare if we have to send it up again or not. """
        return hash((self.error_type, self.stack))


def compress_error(error: RobotError) -> bytes:
    """
        This will be used in the characteristic.
        limit the max size to 500 bytes:
        1 byte: type
        1 byte: ref
        500 bytes: stack trace, that contains the error message at the end.
    """
    stack = error.stack

    # No compression: just dump it as characters, see how that's doing.
    # TODO: cut version number too, as it's in the mobile already.
    if isinstance(error.stack, str):
        stack = error.stack.replace('/home/pi/RevvyFramework/user/packages/revvy-', '')
        stack = stack.encode()

    stack = stack[-500:]

    ret_array = error.error_type.value.to_bytes(1, 'big')
    ret_array += error.ref.to_bytes(1, 'big')

    ret_array += stack

    return ret_array

class ErrorHandler:
    """
        Handles three types of exceptions:
            - user generated exceptions generated by blockly
                - foreground (button) or
                - background programs (autonomous mode))
            - uncaught system exceptions coming from the pi-firmware
            - errors from the MCU coming through querying the PCB on the I2C bus
                - on every "reset configuration" this should be called to clear the error queue

        The list of errors gather in the error_queue that is being sent to the app.
        Errors that are already in the map, are not added to the queue again.
        They also need to be truncated to 500 bytes to go through a single BLE packet.
    """

    def __init__(self):
        self._error_queue : List[RobotError] = []
        self._error_map : Dict[int, RobotError] = {}
        self.register_uncaught_exception_handler()

    def handle_uncaught_system_exception(self, exception_type, value, trace):
        """ Log uncaught exceptions and put them in a queue for reporting."""
        trace = "\t".join(traceback.format_tb(trace))
        log_message = f'U: {exception_type}\nValue: {value}\nTraceback: \n\t{trace}\n\n'

        self.report_error(RobotErrorType.SYSTEM, trace)

        log(log_message, LogLevel.ERROR)
        log.flush()


    def register_uncaught_exception_handler(self) -> None:
        sys.excepthook = self.handle_uncaught_system_exception
        log('Uncaught exception handler registered')
        log.flush()

    def pop_error(self):
        """ Remove and return the last element of the array """
        return self._error_queue.pop()

    def has_error(self):
        """ True if error queue not empty """
        return self._error_queue

    def report_error(self, error_type: RobotErrorType, trace: str, ref: int = 0):
        """ Send error to the queue up if it hasn't been posted already. """
        new_robot_error = RobotError(error_type, trace, ref)
        error_hash = new_robot_error.hash()
        if error_hash not in self._error_map:
            self._error_map[error_hash] = new_robot_error

            # Insert at the beginning of the list. (FIFO)
            self._error_queue.insert(0, new_robot_error)
            log('Error QUEUED')
        else:
            log('Caught error reported already, not reporting again.')
        return new_robot_error

    def read_mcu_errors(self, robot_control: RevvyControl):
        """ Also clears the error queue on the MCU. """
        error_reader = McuErrorReader(robot_control)
        log('Reading MCU errors...')
        for error_entry in error_reader.read_all():
            self.report_error(RobotErrorType.MCU, error_entry)

        # This is not super ideal as we are not making sure that the error
        # actually gets sent up, however we do run this function only
        # when the BLE interface has connected, so it should be fine.
        if error_reader.count:
            error_reader.clear()


revvy_error_handler = ErrorHandler()
