Software architecture
=====================

This firmware was built using CGlue, an in-house developed firmware architecture and toolkit. Most of the custom-developed firmware is organized into
software components that are connected by a runtime layer generated by CGlue. The component models are individually described in the components' folders,
the port connections are configured in the `project.json` file in the root folder.
Because CGlue is missing some features, some of the software components contain manual modifications to the generated component structure or runtime layer.
An example for this is the communication layer: currently, it is not possible to describe, which command IDs belong to which command handler functions,
so these connections are done in a manually written source file.

The other substantial part of the firmware is the code provided by Atmel/Microchip. Some of their SDK is used as-is, but other parts, for example the
SERCOM codes have been modified, replaced or removed from the package.

> This needs to be expanded. CGlue is complicated. It has it's own [documentation](https://github.com/STEAM-Academy-PRO/revolution-robotics-CGlue?tab=readme-ov-file#cglue--).

Developing with CGlue
---------------------

* Create a new software component: `cglue --new-component ComponentName`
* Update generated component code based on modification of the component model: `cglue --update-component ComponentName [--cleanup]`
* Generate runtime based on the project.json configuration: `cglue --generate --cglue-output=rrrc/generated_runtime [--cleanup]`
  The generated files are: `rrrc/generated_runtime.h` and `rrrc/generated_runtime.c`
* Generate makefile for compilation: `python -m tools.generate_makefile [--cleanup]`

General concepts
----------------

### Ports, port drivers

Due to hardware design details, ports are grouped by functionality into **motor ports** and **sensor ports**.
The C implementation has three distinct parts:
- A `CommWrapper` component, which is responsible for processing commands from the python firmware
- A `PortHandler` component, which implements the actual port drivers, reacts to commands coming
  from the associated `CommWrapper` and exposes status information via a status slot
- The `McuStatusSlots` component which takes the exposed status information and makes it available
  for the python firmware to read back. This status information is read by the python firmware
  periodically. Once read, the associated status slot is cleared to avoid wasting bandwidth.